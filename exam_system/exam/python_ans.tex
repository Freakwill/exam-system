%!TEX program = xelatex

\documentclass[12pt,a4paper]{ctexart}%
\usepackage[T1]{fontenc}%
\usepackage[utf8]{inputenc}%
\usepackage{lmodern}%
\usepackage{textcomp}%
\usepackage{lastpage}%
\usepackage{mathrsfs, amsfonts, amsmath, amssymb}%
\usepackage{enumerate}%
\usepackage{exampaper}%
\usepackage{fancyhdr}%
\usepackage{geometry}%
\usepackage{listings}%
\usepackage{ragged2e}%
%
\geometry{left=3.3cm,right=3.3cm,top=2.3cm,foot=1.5cm}%
\pagestyle{fancy}%
\chead{\footnotesize{\textbf{人民大学{-}雁栖湖人工智能学院考试命题纸}}}%
\cfoot{\footnotesize{第~\thepage~页~(共~\pageref{LastPage}~页)}}%
\renewcommand{\headrulewidth}{0pt}%
%
\begin{document}%
\normalsize%
\begin{center}%
\Large{\textbf{北京雁栖湖数学与人工智能学院2025-2026学年第一学期《Python程序设计》课程期末考试试卷（A卷）}}%
\end{center}%
\begin{center}%
\begin{tabular}{cccccc}%
\textbf{考试形式：}&\multicolumn{2}{c}{($\square$闭卷/$\square$开卷)}&\multicolumn{3}{c}{}\\%
姓名&\autolenunderline{}&学号&\autolenunderline{}&教师姓名&\autolenunderline{}\\%
\end{tabular}%
\end{center}%
\vspace{10pt}%
\thispagestyle{plain}%
\noindent%
\textbf{一、填空题 (本题满分40分，每空 2 分, 共 20 空):}%
\begin{enumerate}[1)]%
\item%
说程序设计体现 Python 简洁明了的风格的形容词是\autolenunderline{pythonic};%
\item%
写出为变量hello赋值为字符串\verb|Hello, Professor|的语句: \autolenunderline{hello="Hello, Professor"};
%
\item%
运算符\autolenunderline{+}可以将多个字符串拼接起来;
%
\item%
Python中进行幂运算的运算符是\autolenunderline{**};
%
\item%
C 语言中的数组类似于 Python 中的\autolenunderline{`list`}类型;%
\item%
程序工作目录为'/beijing/haidian', 文件'bimsa.txt'在文件夹'/beijing/huairou'中，该文件的绝对路径和相对路径分别为：\autolenunderline{../huairou/bimsa.txt}、\autolenunderline{/beijing/huairou/bimsa.txt};%
\item%
Python脚本文件后缀是\autolenunderline{.py};%
\item%
函数返回语句的关键字是: \autolenunderline{return};%
\item%
循环语句中，Python 的控制命令有: \autolenunderline{break}、\autolenunderline{continue};%
\item%
读取文件内容前，一般用\autolenunderline{open}函数创建文件对象;%
\item%
定义类方法的关键字是：\autolenunderline{def};%
\item%
至少写出两个你熟悉的标准库: \autolenunderline{os}、\autolenunderline{pathlib};%
\item%
表示服务器已成功处理了客户端的请求，并将请求的资源正常返回给客户端的状态码是: \autolenunderline{200};%
\item%
下面两处\verb|print|命令打印出的结果分别是\autolenunderline{angela}、\autolenunderline{angelababy};
\begin{lstlisting}[language=python]
x = "angela"
def f(x):
    x += "baby"
    print(x)
    return x
f(x)
print(x)

\end{lstlisting}
%
\item%
下面两处\verb|print|命令打印出的结果分别是\autolenunderline{4}、\autolenunderline{4};
\begin{lstlisting}[language=python]
plans = ["学习", "旅游", "玩游戏"]
def add_plan():
    plans.append("刷视频")
    print(len(plans))  # 打印plans元素个数
add_plan()
print(len(plans))

\end{lstlisting}
%
\end{enumerate}%


%
\noindent%
\textbf{二、判断题 (本题满分20分，每题 2 分, 共 10 题):}%
\begin{enumerate}[1)]%
\item%
命令\verb|from mypackage import foo|在导入包中的变量foo同时，也会导入包\verb|mypackage|自身;
\hfill~~\false%
\item%
Python 是一种动态类型面向对象的过程式解释型语言;\hfill~~\true%
\item%
Python 有 \verb|do-while| 语句;\hfill~~\false%
\item%
Python中没有函数指针的概念，函数的行为和普通变量是一样的;\hfill~~\true%
\item%
继承时，子类通常会自动拥有父类方法，且可重写父类方法;
\hfill~~\true%
\item%
用open函数打开文件得到的返回值是文件中的内容;\hfill~~\false%
\item%
Python 没有 goto 语句;\hfill~~\true%
\item%
Python的布尔型其实是特殊的整型;\hfill~~\true%
\item%
Python 比 C、Java 容易学;\hfill~~\true%
\item%
类\verb|Hero|中定义了方法\verb|attack|。\verb|attack|可用\verb|Hero.attack|或通过其对象访问;
\hfill~~\true%
\end{enumerate}%


%
\noindent%
\textbf{三、选择题 (本题满分40分，每题 4 分, 共 10 题):}%
\begin{enumerate}[1)]%
\item%
关于内建变量解释正确的是？\hfill~~\mypar{B}\\
(A) 内建变量只能在函数内使用~~(B) 内建变量是 Python 预先定义好可直接使用的\\
(C) 内建变量不可重新赋值~~(D) 内建变量都以双下划线开头和结尾%
\item%
为学生名单列表\verb|students|增加两位新同学"M"和"L"，可行的命令是？\hfill~~\mypar{B}\\
(A) \verb|students.append("M, L")|
~~(B) \verb|students.append("M"); students.append("L")| 
\\
(C) \verb|students.extend("M", "L")|
~~(D) \verb|students + ["M", "L"]|
%
\item%
下面哪个起到流程控制作用的关键字不是Python的关键字;\hfill~~\mypar{D}\\
(A) break~~(B) continue~~(C) return~~(D) goto%
\item%
实现主机之间网络连接的标准方法是建立;\hfill~~\mypar{C}\\
(A) Wifi~~(B) 接口对象~~(C) 套接字对象~~(D) 局域网%
\item%
文件操作完毕后，应该;\hfill~~\mypar{D}\\
(A) 直接退出程序~~(B) 关机~~(C) 拔电源~~(D) 关闭文件对象%
\item%
下面哪个是Python创建函数的关键字;\hfill~~\mypar{A}\\
(A) def~~(B) func~~(C) class~~(D) function%
\item%
设类\verb|Hero|中定义了对象属性\verb|damage|，\verb|hero|是\verb|Hero|的对象。正确访问属性\verb|damage|的命令是;\hfill~~\mypar{A}\\
(A) \verb|hero.damage|~~(B) \verb|hero['damage']|\\
(C) \verb|herro(damage)|~~(D) \verb|damage.hero|%
\item%
通过\verb|from PIL import Image|导入包之后，下面不可以做的是;
\hfill~~\mypar{A}\\
(A) 直接使用变量\verb|PIL|~~(B) 直接使用变量\verb|Image|\\
(C) 为变量\verb|Image|赋值~~(D) 为变量\verb|PIL|赋值%
\item%
for循环不能用于遍历什么类型的数据;\hfill~~\mypar{C}\\
(A) 元组~~(B) 字典~~(C) 整数~~(D) 字符串%
\item%
下面哪个是不合法的命令;\hfill~~\mypar{A}\\
(A) \verb|class = 0|~~(B) \verb|class_ = 520|\\
(C) \verb|print = 520|~~(D) \verb|print(520)|%
\end{enumerate}%


%
\end{document}