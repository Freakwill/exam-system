%!TEX program = xelatex

\documentclass[12pt,a4paper]{ctexart}%
\usepackage[T1]{fontenc}%
\usepackage[utf8]{inputenc}%
\usepackage{lmodern}%
\usepackage{textcomp}%
\usepackage{lastpage}%
\usepackage{mathrsfs, amsfonts, amsmath, amssymb}%
\usepackage{enumerate}%
\usepackage{exampaper}%
\usepackage{fancyhdr}%
\usepackage{geometry}%
\usepackage{listings}%
\usepackage{ragged2e}%
\usepackage{multirow}%
%
\geometry{left=3.3cm,right=3.3cm,top=2.3cm,foot=1.5cm}%
\pagestyle{fancy}%
\chead{\footnotesize{\textbf{人民大学{-}雁栖湖人工智能学院考试命题纸}}}%
\cfoot{\footnotesize{第~\thepage~页~(共~\pageref{LastPage}~页)}}%
\renewcommand{\headrulewidth}{0pt}%
%
\begin{document}%
\normalsize%
\begin{center}%
\Large{\textbf{人民大学-雁栖湖人工智能学院第 2025/2026 学年\\第 1 学期试卷}}%
\end{center}%
\begin{center}%
\begin{tabular}{lclclc}%
课程&\multicolumn{2}{c}{\autolenunderline{\_\_\_\_\_\_\_\_\_\_\_\_\_\_}}&班级&\multicolumn{2}{c}{\autolenunderline{\_\_\_\_\_\_\_\_\_\_\_\_\_\_}}\\%
姓名&\autolenunderline{}&学号&\autolenunderline{}&教师姓名&\autolenunderline{}\\%
\end{tabular}%
\end{center}%
\begin{center}%
\begin{tabular}{|c|c|c|c|c|c|}%
\hline%
\sws{题号}&\sws{一}&\sws{二}&\sws{三}&\sws{四}&\sws{总评}\\%
\hline%
\multirow{2}{*}{计分}&&&&&\\%
&&&&&\\%
\hline%
\end{tabular}%
\end{center}%
\thispagestyle{plain}%
\noindent 一、填空题 (每空 2 分, 共 20 空):%
\begin{enumerate}[1)]%
\item%
Python 的格言是 \autolenunderline{人生苦短}, 我用 Python;%
\item%
说程序设计体现 Python 简洁明了的风格的形容词是\autolenunderline{pythonic};%
\item%
为了实现“乘坐马斯克的星舰飞向太空”的梦想，用户可先用\autolenunderline{pip}下载具有该功能的\autolenunderline{第三方库} (如\verb|starship|), 然后在 Python 的脚本文件中使用\autolenunderline{import}关键字导入;
%
\item%
写出为变量hello赋值为字符串\verb|Hello, Professor|的语句: \autolenunderline{hello="Hello, Professor"};
%
\item%
运算符\autolenunderline{+}可以将多个字符串拼接起来;
%
\item%
Python中进行幂运算的运算符是\autolenunderline{**};
%
\item%
写出至少三种内建类型: \autolenunderline{int}、\autolenunderline{float}、\autolenunderline{str};%
\item%
C 语言中的数组类似于 Python 中的\autolenunderline{`list`}类型;%
\item%
C 语言中的结构体类似于 Python 中的\autolenunderline{`dict`}类型;%
\item%
程序工作目录为'/beijing/haidian', 文件'bimsa.txt'在文件夹'/beijing/huairou'中，该文件的绝对路径和相对路径分别为：\autolenunderline{../huairou/bimsa.txt}、\autolenunderline{/beijing/huairou/bimsa.txt};%
\item%
Python脚本属于\autolenunderline{文本}文件，用\autolenunderline{w}方法写入（保存或另存为），用\autolenunderline{r}方法读取;%
\item%
Word文档属于\autolenunderline{二进制}文件，用\autolenunderline{wb}方法写入（保存或另存为），用\autolenunderline{rb}方法读取;%
\item%
Python脚本文件后缀是\autolenunderline{.py};%
\item%
如果函数没有返回语句，那么它默认返回: \autolenunderline{None};%
\item%
函数返回语句的关键字是: \autolenunderline{return};%
\item%
定义函数的关键字是: \autolenunderline{def};%
\item%
匿名函数的关键字是: \autolenunderline{lambda};%
\item%
循环语句中，Python 的控制命令有: \autolenunderline{break}、\autolenunderline{continue};%
\item%
读取文件内容前，一般用\autolenunderline{open}函数创建文件对象;%
\item%
文件操作结束时候要执行\autolenunderline{close}命令;%
\item%
创建文件对象的常用语法糖是\autolenunderline{with}语句;%
\item%
定义类方法的关键字是：\autolenunderline{def};%
\item%
至少写出两个你熟悉的标准库: \autolenunderline{os}、\autolenunderline{pathlib};%
\item%
下载第三方库\verb|numpy|, 库中有子模块\verb|random|, 子模块中定义了函数\verb|rand|; 如何直接导入\verb|rand|: \autolenunderline{from numpy.random import rand}%
\item%
Python 网络爬虫中堪称绝配的两个第三方库/模块: \autolenunderline{`requests`}、\autolenunderline{`bs4`};%
\item%
表示服务器已成功处理了客户端的请求，并将请求的资源正常返回给客户端的状态码是: \autolenunderline{200};%
\item%
连接某个主机时，通常要先获得服务器的具体地址，包括\autolenunderline{IP地址}、\autolenunderline{端口号}两部分;%
\item%
下面两处\verb|print|命令打印出的结果分别是\autolenunderline{angela}、\autolenunderline{angelababy};
\begin{lstlisting}[language=python]
x = "angela"
def f(x):
    x += "baby"
    print(x)
    return x
f(x)
print(x)

\end{lstlisting}
%
\item%
下面两处\verb|print|命令打印出的结果分别是\autolenunderline{4}、\autolenunderline{4};
\begin{lstlisting}[language=python]
plans = ["学习", "旅游", "玩游戏"]
def add_plan():
    plans.append("刷视频")
    print(len(plans))  # 打印plans元素个数
add_plan()
print(len(plans))

\end{lstlisting}
%
\end{enumerate}%


%
\noindent 二、判断题 (每空 2 分, 共 10 空):%
\begin{enumerate}[1)]%
\item%
Python 比 C、Java 容易学;~~\true%
\item%
学习 Python 是一件非常快乐，非常有成就感的事情;~~\true%
\item%
lambda 符合标识符的文法，因此可作为变量名;
~~\false%
\item%
Python 是一种动态类型面向对象的过程式解释型语言;~~\true%
\item%
相比传统计算机语言，Python 运行速度比较慢，但开发效率高;~~\true%
\item%
Python的布尔型其实是特殊的整型;~~\true%
\item%
对 Python 来说，缩进具有语法功能;~~\true%
\item%
Python 没有 goto 语句;~~\true%
\item%
字符串的值一旦改变（比如接上其他字符串）其id一定改变~~\true%
\item%
列表的值一旦改变（比如接上其他列表）其id一定改变~~\true%
\item%
Python 的 \verb|for/while| 循环语句和 \verb|if| 语句一样可以接 \verb|else|;~~\true%
\item%
Python 有 \verb|do-while| 语句;~~\false%
\item%
Python 有 case 语句;~~\false%
\item%
Python中没有函数指针的概念，函数的行为和普通变量是一样的;~~\true%
\item%
Python 中的函数不能作为另一个函数的参数或返回值;~~\false%
\item%
不能在Python 的函数内部操作全局变量;~~\false%
\item%
函数内部不能调用函数自身，否则会陷入无限循环;~~\false%
\item%
用with 语句执行完文件后，应该执行close方法以确保完成对硬盘中文件的操作;~~\false%
\item%
用open函数打开文件得到的返回值是文件中的内容;~~\false%
\item%
如果要为某个类定义“+”方法，直接定义\verb|def +(self, other): pass|即可;
~~\false%
\item%
类\verb|Hero|中定义了方法\verb|attack|。\verb|attack|可用\verb|Hero.attack|或通过其对象访问;
~~\true%
\item%
继承时，子类通常会自动拥有父类方法，且可重写父类方法;
~~\true%
\item%
定义类Animal之后, 用Animal()新建对象时，程序会自动调用方法\verb|__init__|;
~~\true%
\item%
无论包\verb|mypackage|安装在哪里，\verb|import mypackage|都会自动搜索并导入该包;
~~\false%
\item%
命令\verb|from mypackage import foo|在导入包中的变量foo同时，也会导入包\verb|mypackage|自身;
~~\false%
\item%
只要文件夹的名称正常，并且在其中创建文件\verb|__init__.py|，那么它就是Python包;
~~\true%
\item%
requests的get方法可以不受限制地访问任何网站并下载其上的资源;
~~\false%
\end{enumerate}%


%
\noindent 三、选择题 (每空 4 分, 共 10 空):%
\begin{enumerate}[1)]%
\item%
Python 的吉祥物是;~~\mypar{D}\\
(A) 一只袋鼠~~(B) 一只企鹅~~(C) 一只章鱼~~(D) 一条蟒蛇%
\item%
Python发明人是在什么情况下发明Python的？~~\mypar{C}\\
(A) 内心迷茫的时候~~(B) 在实验室里专研~~(C) 度假时候无聊打发时间~~(D) 泡咖啡馆奇思妙想%
\item%
下面哪个不能作为Python的变量？~~\mypar{D}\\
(A) print~~(B) int~~(C) CONSTANT~~(D) def%
\item%
存储个人信息时，最适合采用什么数据类型？~~\mypar{B}\\
(A) 元组~~(B) 字典~~(C) 列表~~(D) 集合%
\item%
关于内建变量解释正确的是？~~\mypar{B}\\
(A) 内建变量只能在函数内使用~~(B) 内建变量是 Python 预先定义好可直接使用的\\
(C) 内建变量不可重新赋值~~(D) 内建变量都以双下划线开头和结尾%
\item%
学习编程的第一个命令是？~~\mypar{A}\\
(A) 打印Hello World~~(B) 打印Hello Kitty\\
(C) 打印Hello Kugou~~(D) 打印Hey man%
\item%
下面哪个是可变变量的类型？~~\mypar{C}\\
(A) 字符串~~(B) 数字~~(C) 列表~~(D) 元组%
\item%
下面关于字典\verb|card={"number":3, "suit":"club"}|的使用（语法上）错误的是？~~\mypar{A}\\
(A) \verb|card.number=3|
~~(B) \verb|card["number"]="A"| 
\\
(C) \verb|card[3]=card["number"]|
~~(D) \verb|card["suit"]=input()|
%
\item%
为学生名单列表\verb|students|增加两位新同学"M"和"L"，可行的命令是？~~\mypar{B}\\
(A) \verb|students.append("M, L")|
~~(B) \verb|students.append("M"); students.append("L")| 
\\
(C) \verb|students.extend("M", "L")|
~~(D) \verb|students + ["M", "L"]|
%
\item%
关于列表说法正确的是？~~\mypar{D}\\
(A) 列表中的元素不能再是列表~~(B) 列表中的元素不能是元组\\
(C) 列表中的元素类型必须相同~~(D) 在表示数据方面，列表和元组没有明显区别%
\item%
下面那个命令会导致变量id的变化？~~\mypar{D}\\
(A) \verb|x="LoL"; print(x)|
~~(B) \verb|x=["LoL"]; x.append("Honor of Kings")| 
\\
(C) \verb|x=["LoL"]; x += ["Honor of Kings"]|
~~(D) \verb|x="LoL"; x += "Honor of Kings"|
%
\item%
将列表\verb|cmd=["pip", "install", "pygame"]|拆分为\verb|cmd="pip"|, \verb|args=["install, "pygame"]|两部分，最便捷的有效方法是？~~\mypar{D}\\
(A) \verb|cmd = cmd[0]; args = cmd[1:]|
~~(B) \verb|args = cmd[1:]; cmd = cmd[0]| 
\\
(C) \verb|cmd, *args = cmd|
~~(D) \verb|cmd, args = cmd|
%
\item%
文件操作完毕后，应该;~~\mypar{D}\\
(A) 直接退出程序~~(B) 关机~~(C) 拔电源~~(D) 关闭文件对象%
\item%
下面哪个起到流程控制作用的关键字不是Python的关键字;~~\mypar{D}\\
(A) break~~(B) continue~~(C) return~~(D) goto%
\item%
for循环不能用于遍历什么类型的数据;~~\mypar{C}\\
(A) 元组~~(B) 字典~~(C) 整数~~(D) 字符串%
\item%
方法\verb|.items|常用与什么类型数据的遍历;~~\mypar{B}\\
(A) 元组~~(B) 字典~~(C) 列表~~(D) 字符串%
\item%
下面哪个是Python创建函数的关键字;~~\mypar{A}\\
(A) def~~(B) func~~(C) class~~(D) function%
\item%
定义函数 \verb|def foo(x, y, z:int=1, *args, **args): pass|。正确调用这个函数的命令是;
~~\mypar{B}\\
(A) \verb|foo(1)|~~(B) \verb|foo(1, 2, 3, 'hello')|\\
(C) \verb|foo(1, y=2, z='hello')|~~(D) \verb|foo(y=3, 2, 3)|%
\item%
下面哪个是Python创建类的关键字;~~\mypar{C}\\
(A) def~~(B) classdef~~(C) class~~(D) cls%
\item%
下面哪个是Python新建对象的关键字;~~\mypar{D}\\
(A) init~~(B) new~~(C) cls~~(D) 没有关键字%
\item%
设\verb|Card|是类名，card是其对象，则下述说法错误的是;~~\mypar{D}\\
(A) Card也是变量~~(B) Card可像函数一样调用\\
(C) card的类型是Card~~(D) Card本身无类型%
\item%
下面哪个是Python初始化对象的方法;~~\mypar{B}\\
(A) \verb|__new__|~~(B) \verb|__init__|~~(C) \verb|_new_|~~(D) \verb|_init_|%
\item%
设类\verb|Hero|中定义了对象属性\verb|damage|，\verb|hero|是\verb|Hero|的对象。正确访问属性\verb|damage|的命令是;~~\mypar{A}\\
(A) \verb|hero.damage|~~(B) \verb|hero['damage']|\\
(C) \verb|herro(damage)|~~(D) \verb|damage.hero|%
\item%
设类\verb|Hero|中定义了方法\verb|def attack(self, other): ...|，\verb|hero|是\verb|Hero|的对象。正确调用这个方法的命令是;
~~\mypar{A}\\
(A) \verb|hero.attack(other)|~~(B) \verb|attack(self, other)|\\
(C) \verb|Hero.attack(other)|~~(D) \verb|hero.attack("other")|%
\item%
子类Knight继承父类Hero的语法是;~~\mypar{D}\\
(A) \verb|subclass Knight(Hero)|~~(B) \verb|Knight extend Hero|\\
(C) \verb|child Knight(Hero)|~~(D) \verb|class Knight(Hero)|%
\item%
下面哪个是Python导入包的关键字;~~\mypar{B}\\
(A) \verb|include|~~(B) \verb|import|~~(C) \verb|export|~~(D) \verb|use|%
\item%
安装包\verb|bs4|后，用户想直接在脚本中使用包中的类\verb|BeautifulSoup|，那么应该先做什么;
~~\mypar{C}\\
(A) 无需导入直接使用BeautifulSoup~~(B) \verb|import bs4 as BeautifulSoup|\\
(C) \verb|from bs4 import BeautifulSoup|~~(D) \verb|import BeautifulSoup| from bs4%
\item%
通过\verb|from PIL import Image|导入包之后，下面不可以做的是;
~~\mypar{A}\\
(A) 直接使用变量\verb|PIL|~~(B) 直接使用变量\verb|Image|\\
(C) 为变量\verb|Image|赋值~~(D) 为变量\verb|PIL|赋值%
\item%
下面哪个是不合法的命令;~~\mypar{A}\\
(A) \verb|class = 0|~~(B) \verb|class_ = 520|\\
(C) \verb|print = 520|~~(D) \verb|print(520)|%
\item%
下面哪个赋值命令可以正常运行;~~\mypar{B}\\
(A) \verb|score := 100|~~(B) \verb|score:str = 100|\\
(C) \verb|int score = 100|~~(D) \verb|score == 100|%
\item%
关于下述程序，下面说法错误的是;
\begin{lstlisting}[language=python]
x = ["Hello"]
def f():
    x.append("RUC")
f()
print(" ".join(x))

\end{lstlisting}
~~\mypar{D}\\
(A) 最后打印结果为Hello RUC~~(B) 第一个\verb|x|为全局变量\\
(C) \verb|f()|中的\verb|x|为全局变量~~(D) \verb|f()|中的\verb|x|为局部变量%
\item%
实现主机之间网络连接的标准方法是建立;~~\mypar{C}\\
(A) Wifi~~(B) 接口对象~~(C) 套接字对象~~(D) 局域网%
\end{enumerate}%


%
\noindent 四、计算题 (每题 10 分, 共 2 题):%
\begin{enumerate}[1)]%
\item%
下面是函数定义与调用代码. 请指出的所有Bug.
\begin{lstlisting}[language=python]
def play(name, game='Royal Crash', time):
    # 定义函数play
    # 本程序用于调查学生玩游戏时间

    print('Student: ', name)
    print(f'play {game} with {time} hours!')

    if time > 3
        print(f'{name} is a bad student.')
    else time > 1:
        print(f'Just so so.')
    else:
        print(f'Teachers will like {name}.')

play(name='Mario', 'Pokemon', 3)   # 第一次调用
play(0.5, game='CS, name='Steve')  # 第二次调用

\end{lstlisting}


\vspace{10cm}%
\item%
下面是函数定义与调用代码. 请指出三处Bug.
\begin{lstlisting}[language=python]
function guess_price():
    # 定义函数 guess_price
    # 本程序用于实现一个多轮猜价格游戏

    price = 50
    guess_times = 0
    while guess_times < 3:
        guess = input("请输入你的猜测: ")
        guess_times += 1
        if guess = price:
            print("恭喜你猜对了!")
            return
        elif guess > price:
            print("你的猜测太高了.")
        else:
            print("你的猜测太低了.")
    print("你已经用完了所有的猜测机会.")
    print("正确的价格是:", price)

guess_price()  # 调用函数

\end{lstlisting}


\vspace{10cm}%
\end{enumerate}%
\end{document}